先日開催されたSatokiCTFで Sickle 2.0という問題を出題したのでそれのWriteupになります。

## Prerequisite

- Pickleの仕様
  - [cpython/Lib/pickle.py at main · python/cpython](https://github.com/python/cpython/blob/main/Lib/pickle.py): これ読んで
- API Hashing

## TL;DR

- Pickle上で擬似的な関数呼び出しとレジスタを実現しついでに難読化をそこそこ施したVM
    - 流れはVM初期化 → 入力の取得と長さのチェック → 入力と対応するベクトルに左から行列を掛けてその結果を照合 → VMのコンテキストを爆破して終了
- デシリアライズの際に`pickle.loads`で別のバイトコードをデシリアライズすることで実質的に関数呼び出しを実現
- `load_extension`を内部で呼び出す`EXT1`, `EXT2`, `EXT4`は (本来の目的を無視すれば)`copyreg._extension_cache`から要素を取得するため、ここを引数渡しのレジスタやグローバルアクセス可能な領域として利用
- 書き込みはこの領域が辞書なので `SETITEM`や `SETITEMS`を使うと実現可能
- 多くの `STACK_GLOBAL` での呼び出しをAPI Hashingにして難読化

## 実装した~~嫌がらせ~~難読化

- バイトコード中で`pickle.loads()`を`REDUCE`で呼び出して各機能を実行することで配布されたバイトコードだけを逆アセンブルしても意味が無いようにした
- 0から255までの値、関数やメソッド名のような登場するとわかっている文字列、後述のAPI Hashingで使用するハッシュ、内部の`pickle.loads`で呼び出すバイトコードを全て`copyreg._extension_cache`に放り込んでバイトコードやその逆アセンブル結果からのGuessを困難にした
- バイト列中に`REDUCE`で呼び出す関数は大抵`GLOBAL`や`STACK_GLOBAL`で取得するが、この際バイトコード中にモジュールとオブジェクト名が直書きされることでGuessが可能なのでAPI Hashingと同様の方法で習得
- 実行終了後の`copyreg._extension_cache`を確認するとどのインデックスにどの要素があるのかが丸わかりなので、最後に`copyreg.clear_extension_cache`を呼び出して空にした
    - これを呼び出さなければ余裕で回避可能
- 再帰的なバイトコードの呼び出しによるループの実装
    - Pickleには制御構文用のオペコードが無く、`map`や`filter`を`REDUCE`で呼び出す以外にループを実現することが困難
    - 今回は`pickle.loads`で別のバイトコードを呼び出せるので、そこで再帰呼び出しをすればループができる
    - `def f(loop_cnt): ...`のような関数を呼び出して`loop_cnt`の値を操作 (インクリメントやデクリメント) し、その結果次第で再帰呼び出しするか何もしない (呼び出し元に戻る) かで分岐する

## 難読化詳細

### API Hashing

Pickleで`from module import something`相当の事をする際は`STACK_GLOBAL`や`GLOBAL`オペコードを使用します。しかし前者はスタックトップの2つの文字列を用いることから、付近に文字列をpushする命令があると何をインポートしているかが直ぐわかります (実際バイトコードの先頭で`pickle.loads`をインポートしている)。後者の場合は後続のバイト列をそのまま使用するため、逆アセンブルすればスタックの様子を見ずとも確認可能です。これまでPickleのRevを解いたり作ったりしてきた中で、このオペコードがGuessの要因や解析ツールの支援となることがあったのでなんとかしてそれを防ぎたいと思って生まれたのがPickle中でAPI Hashingを行うという発想です。

API Hashingの仕組みは単純で、関数呼び出しの際にハッシュをリゾルバに渡し、リゾルバはライブラリやその中にある関数を列挙してハッシュ化しながら一致するものを探して該当の関数を返すものとなります。Windowsのマルウェアや位置独立なシェルコードが関数ポインタを取得する際に見られるテクニックらしいです。

Pythonでは`sys.modules`に標準ライブラリから読み込めるモジュールが名前をキーとした辞書で入っているため、ここを列挙&ハッシュ化していけばモジュール名の解決は可能です。モジュールが手に入ったらこれに対して`dir`関数を実行することで要素名を列挙出来ます。この中には当然モジュール内の関数も含まれているため、そのハッシュ値を指定することで無事に関数が取得出来ます。

問題作成用のスクリプトを確認したら次のような事をしていました。

```python
list(
    map(
        _hashlib.HASH.hexdigest, 
        map(
            hashlib.sha256,  # -> sha3_512 
            map(
                builtins.str.encode,
                sys.modules.keys()
                # or: dir(sys.modules["copyreg"])
            )
        )
    )
)
```

なお、最初はSHA256でハッシュ化していましたが、Crackstationでハッシュ値を解析したらcopyregは出てきてしまったのでSHA3_512に変更しました。

### バイトコード中で`pickle.loads`

pickleのバイトコードでは`REDUCE`オペコードを使うことで、任意のPythonの関数を呼ぶことが出来るというのは言わずとしれた事実です。したがって、`pickle.loads`も当然呼ぶことができることからバイトコード中で別のバイトコードを実行出来ます。

この部分の例として[chall.pkl](./chall.pkl)の逆アセンブル結果を載せます。

```
    0: \x8c SHORT_BINUNICODE 'pickle'
    8: \x8c SHORT_BINUNICODE 'loads'
   15: \x93 STACK_GLOBAL
   16: B    BINBYTES   (略)
10482: \x85 TUPLE1
10483: R    REDUCE
```

スタックに`pickle.loads`とバイト列をpushして`REDUCE`で呼び出すことでこのバイト列が実行されます。

これでプログラミング言語における関数呼び出しに相当することが可能になります。この問題では難読化に用いるあらゆる値 (API Hashingのハッシュ値、`getattr`や`int.__add__`のような汎用的なビルトインの関数、このような形で呼び出されるバイト列) を後述のグローバル領域 (`copyreg._extension_cache`) に配置する処理をはじめとしていくつかの処理をバイト列に分解して呼び出しています。

但し、特に工夫を施さない場合は引数を渡すことが出来ないのでこれを実現する手段が必要です。

### `copyreg._extension_cache`や`EXT<n>`オペコード

今回の肝となるのが`EXT1, EXT2, EXT4`オペコードが呼ばれた時に参照される`copyreg._extension_cache`を利用したグローバル領域の実現です。前述の`pickle.loads`の多重呼び出しでは引数に対応するものが無いというクソデカい問題がありましたが、これによって解決します。

これらのオペコードが呼ばれると、内部では[`get_extension`](https://github.com/python/cpython/blob/main/Lib/pickle.py/#L1583)と呼ばれる関数が呼び出されます。重要なのは次のコードです。

```python
    def get_extension(self, code):
        nil = []
        obj = _extension_cache.get(code, nil)
        if obj is not nil:
            self.append(obj)
            return
```

この`_extension_cache`の定義は`from copyreg import _extension_registry, _inverted_registry, _extension_cache`となっており ([該当行](https://github.com/python/cpython/blob/main/Lib/pickle.py#L28))は、[`copyreg`というモジュール内の辞書](https://github.com/python/cpython/blob/main/Lib/copyreg.py#L169)を参照しています。

ここで、PickleがPythonでできることならだいたいなんでもできる事を思い出すと、この辞書に要素を入れてそれを`EXT`系のオペコードで取ってくることが出来そうです。Pickleにはスタック上の辞書に対してキーと値を指定するとそれを設定する`SETITEM`や`SETITEMS`というオペコードが存在するため書き込みはこれで可能です。ただ、その都度`STACK_GLOBAL`でスタックに`copyreg._extension_cache`をpushするのは面倒なので、何らかの添字 (今回は0x10を使用。ちなみに0は設定できるものの、`get_extension`で弾かれる) を指定して`_extension_cache[idx] = _extension_cache`のような自己参照を実現し、この添字に対して`EXT<n>`を呼ぶだけでpushできるようにしています。

これだけだとPickleのメモのような領域と手間がかかるだけで大きな違いが無いように見えますが、メモとの大きな違いとしてモジュールに対して施した変更は他のPickleバイトコードでも反映されているということがあります。これを利用して事前にどのインデックスがどの用途で使われるかを定めておけばバイトコード間で値をやり取りすることが可能です。

VMのようなものがこれで実現出来たので、レジスタマシンをモデルにして1-8を汎用レジスタのような扱いにして、それ以外を各バイトコードのための領域にしています。また、0から255のようなよく使う数値や固定の文字列、API Hashingで使うハッシュ値、多重呼び出しで使うバイトコードも全部この中に押し込んで`pickletools.dis`の結果だけではどの要素がスタックにpushされるかをわかり辛くしています。

### 再帰を用いたループ

これで引数を伴う関数呼び出しのようなことが実現したので、最後に再帰関数を用いてループを実現しました。実装は次のようなコードをPickleで書いて`loop_count`が`loop_count_max`に到達していない時は再帰呼び出しを行い、そうでない時は単純に`bytecode`を引数に取ることが可能でかつ副作用が無いもの (今回はid関数) を呼び出すようにしました。

```python
table = [pickle.loads, id]
table[int.__floordiv__(loop_count, loop_count_max)](bytecode)
```

なお、`loop_count`に対応する`_extension_cache`の添字を汎用用途の1にしてしまったため、内部で別のバイトコードを呼び出す際の引数指定によって破壊されて盛大にバグりました。結局、これを回避するためにメモに退避させています。これを書いている最中にx86でいうところのrcxに相当するレジスタを用意して引数とは別の形でループ変数を渡せば退避処理を書かずに済んだことに気づきました。

## 解法

レビューしていないのでどのレベル帯の人が解けるかは想像がつきませんが、手っ取り早いのはpickle.pyやpickletools.py辺りを読んだりコピペしたりして改造していい感じの解析スクリプトを書くことだと思います。この問題に直接適用するのは難しいかもしれませんが、Pickleバイトコードのデバッガを実装した例があります: [Legoclones/pickledbg: A GDB+GEF-style debugger for unloading Python pickles](https://github.com/Legoclones/pickledbg/tree/main)。また、終了後に解いた人は[trailofbits/fickling: A Python pickling decompiler and static analyzer](https://github.com/trailofbits/fickling)を改造して解いたらしいです。

特に、この問題では`pickle.loads`を使ったバイトコードの呼び出しや、使っているところを見たことがない`copyreg._extension_cache`、`EXT`系の命令等、pickle.pyを読んで理解する必要がある概念がそこそこあるのでこの辺のサポートを追加する必要があります。

これをやった上で、API Hashingを利用した`STACK_GLOBAL`の難読化や再帰関数を利用したループには特定の命令列パターンが現れるはずなのでそれを元にして気合で元のPickleのコードや等価なPythonのコードに直していくという気合が必要です。

難読化の正体が分かってしまえば、後はPickleの逆アセンブル結果を気合で読むだけなのでRevに慣れている人なら解けるだろう、という読みでした。Pickleには素直な制御構文がないので、Pythonで標準搭載している高階関数(`map`, `filter`等)や真偽値をインデックスにとって次に呼び出される関数や引数を選ぶといった形で実装された一部のループや条件分岐にも対処する必要があります。

他に必要なテクニックとして、そもそもPickleがスタックマシンなのでメモや`copyreg._extension_cache`に入れる過程であっても必ずスタック上にその要素が現れるので、それを適宜確認するというのがあります。今回の行列演算で使う行列や演算結果の比較対象もどこかのタイミングでスタックに乗るので、そこまでのバイト列を切り出して`pickle.STOP`を末尾に付与してloadするとそれがデシリアライズ結果として返ってきます。

この問題での例を挙げると、フラグチェックで登場する行列が本体をスタックに乗せた後に`getattr(matrix, "__getitem__")`を用いてgetter相当の関数に変換されており、演算時にはスタックに存在していません。そこで、getterを取得する寸前で止めてデシリアライズすることでバイト列の配列にエンコードされた行列を取得することが出来ます。

また、動作全体をなんとなく把握するための方法として、`sys`モジュールが提供する監査フックを利用することがあります。一部の標準ライブラリの機能は利用時に監査イベントを送出し、この際のイベントと引数を引数にとるフック関数を`sys.addaudithook`で設定することが出来ます。監査の対象には`pickle.find_class`が含まれていることから、これを呼び出す`STACK_GLOBAL`や`GLOBAL`がどの関数やオブジェクトをスタックにpushしているかが判明します。以下のコードはそれを実現する簡単な例です。

```python
import sys

def f(event, args):
    print(event, args)

sys.addaudithook(f)
```

これを実行すると次のようになります。

```
$ p trace.py 
open ('./chall.pkl', 'r', 524288)
pickle.find_class ('pickle', 'loads')
pickle.find_class ('builtins', 'getattr')
pickle.find_class ('builtins', 'list')
pickle.find_class ('builtins', 'list')
pickle.find_class ('builtins', 'map')
pickle.find_class ('_hashlib', 'HASH')
import ('_hashlib', None, ...)
以下略
```

## やらなかったこと

- 難読化を解除したとしてもCrackMeパートで公開鍵暗号の知識やSMTソルバを持ち出さないと解けないようにする
    - 今回はただの行列演算
        - `sum(map(int.__mul__, row, col))` を各行でやっている
    - Cryptoではないのでやめた
    - 加えて、どうしてもこのパートはループが発生することから、クソ重たい処理を今回のような再帰で書きたくなかった
- `copyreg._extension_cache`に、何らかのバイトコードへのI/Oを置いておき、そのバイトコード中でそれを操作 (特にseek) することでループを実現
    - 今回のアイデア + SECCON CTF 2023 Quals - Sickleの合わせ技
    - これで擬似的なIP (インストラクションポインタの方) となるので、eval, exec, Pythonバイトコードの利用、ファイルポインタ変数が既知という仮定などを使わずに、Pickleの機能だけで制御構文とレジスタを持つ高機能なスタックベースのVMをシミュレートできる予感
- 動的なバイトコード生成
    - 文字列やバイト列をスタックにpushする際、大抵「オペコード」、「長さ」、「文字列やバイト列に対応するバイト列」のような並びになるので、長さやバイト列の部分をスタックに乗せて`bytes.__add__`や`bytes.join`等で結合すればバイトコードをPickle中で構成できる
    - 当初は別のバイトコードへの引数渡しをこれでやるという案を検討していたが、`copyreg._extension_cache`の発見と研究により終了
- その他、今回の問題の本質に関連しない難読化
    - メモにぶち込む命令 (`PUT`系)はスタックや大抵のコンテキストに影響しないため、使わないインデックスに対して連発すれば実質的なNOPとなる
    - 加えて、バイトコード中で同一インデックスに対する`PUT`を行うとpickletools.pyがエラーを吐いて解析が困難になる
        - pickletools.pyへの対策案はそこそこ抱えているが、ほとんど実装しなかった
    - ここに書くレベルですら無い実質NOPのような命令列の使用 (意味のないスタック操作命令等)

## ソルバ

難読化解除部分は気合なので特にスクリプトのようなものは無いです。[solve_simulate/](./solve_simulate/) ディレクトリにそれっぽい解析をした痕跡は残しています。

参考になるかわかりませんが、フラグを行列演算で加工して比較する部分の逆算用コード ([solve.sage](./solve.sage)) だけ置いておきます。

```python
mat = [b'\xd9\xe4\xd83|miZ\xc4\x15\xacCtE\xce\x1f\x87;\x7f\xc2\xf4\xbbq:\xba\x8b\xb6\x97\xe1\xfbP\xf6\xf6.\xf2\x88\xb1%\xd1\xa0y\xca6\x13H\xec\xee\xf8%\xa2\xb4\xd9\x9a\xe6#H', b'\xc6x\xf9\xf3\x82-y)MY`\x92\x0et\xae\x9epS\xb1\x97(\xa5\xbeI\xf1y\xeb\xec\x86!\xfe\xe0\r~\xaa\xc2\x18\xfc<\xec/\xe8\x97\x9a\x01\xb9\xbb B\xf1U:\x07\xd8\xb2\xa2', b'3\xcaD9?52\x1as@V\xfa\x96~Jg\xc0h3K:\x04\x1c:\x8fB\rq\xbeP\xb7{|sd\xbe\xb3V\xd3\xc3C\x8b\xc7\x82\xcft:c\nS\xa6\xb7V\xb3\xdf\x1d', b"\xa0\xc3[\x88\xa7\x9f`\x020<o97\x01\xbb\x03\xc1'\x01<\xb8\xe9\x13\xdc\xc9%r\xb6\x9eK\xce\xda\x0en\xcd\xf0\x10\x8b\x8e\xb0W\xa9ij\x1cK/\xd8\x9c2\x7f7\x85\xf0\x84\xa1", b'\xef.\x16\xe6\x86>(\x00\x7f\x06\xf6L\xbf%\x17\xf0\xb9\x9c\x8d\xb1\xc4zL\x14\xac\xf6\xf4\xc8+t\x9b\xf7\x93\xf4\xd0Q\x0e(\xfe\xc8\xfeB;\x99\x85m\xb41\xa2,\x1a.\xe1\xdc\\f', b'\t\xa6\x9d\xd5\xe4\x0f\x0b\xf1\n\xaa\xb7\xcbQ\xa7]\xe0\xcc\xb4\n\x96n\x9c\xc7\xddm!\xe2\x89\x84\xe6\xd7\x822oN\xa7w\x99\xb5&\x1e\x91\xcb>A\x80\x14e\xbe\x95\x92\xb9g\xae\x04\xc6', b'\x9d\xb5\xf6(\x19!l\xa0\x88\x89j\xd2\xa8\xaa\xb5\x01\x97\xdf\xa7\x08\xf4\x925LTz\xdct\xf9\xa2&\xc1\xf1\x98\xca\x08\xe2=\xd5\xc1\t!N\xe1(hv\xf6\x13\x88\xb5\xa3\x08\x03\xe1\x1f', b"\x1a2Z\x86\xc2\xdf\xea'\xb8i\xee\xd3X\x05\xbaSR\x10\x92\xa4\xb8Q0\xc8Q\x81e\x13\x0et\xb6\xdb\x9ebc-e<,\x82+}\xc1Y\xd7 \xd7[\x9b\xf4\xc6f\x0e9k\xa9", b'\x89$\x11\xa4\x18H;\xe6\xbd\xfao\xc6?\x81\xbf\x88\xb0\xc2\xb0\x98\xb8\xe0PRL]\xdd\x9bE(\x86\xc9,b\x19\xe0\xe9(v\xa2\xeaBm\x9b\xe6\xecM\x80\xd2\x82\x9b@[B)N', b'{~\x08\x87\xd6\xdf\xefM$b%{y \x9f1.\xe0\x02\xff^t\x18\xa3Wo(^\xb1\x00\x8b\x930z\xcdw\xdb#MhA\xf9oJW\x1b\x1e\xc3\x81&K\x0e\xb4\xa9\xe6\xaa', b'\x03`G\x9cX\xac\x9b\xc2"\x95\xea\xbe\xa3\xc3V\xa6\xb9\xa8)\xabeB~>\x91\x94 \x8b)\xe1\x8b\x15\x16\x1cU\xfa\x05\x9f\xb2#\xecG\x97\xc2\x06=\xce*\x93;;\x9bM\x899\xe2', b'\x18\x80\xe4U\x83\x8c\xa8\xbd\x00\xc1\xbb\xf2\xbd\xdf\xbe\xcf\xdb\xa83`p\xd2\xf9\x01+g\x04\x168\x06\xa8\xf9;z\xfeX\xa1\xeb\x16B$\x81z\x84\xc6r\xeb5y\xdb\xaaDx;r:', b'\x98fis\xdc{H\xf2\x83G\x18\xcf4N.\x01s+\xbc\xc9 \xce\x0f^\xa3\xef5\x9a\njnz\x16gP\xcf\xc3\xef\x82\xb0\x01\x1e\xd0s\x99\x8e\x13\x94R\xcb\xac\x01\x98A\x0f\xd4', b"\xc8\x12\xc8n\x92c\xf6\xf2\x9b*\xdf\xf7\x85'$\xd9\xc8\xa3\xe5&LXQ\x1a\xe9[c\xa0\xbd\xac\xeaQE\xb0\xd0]\xd3\xc1Sd\xa6\xbc\xae\xb3\x9a\xfebw\xed\xe6Q\xa2?b[Z", b'\x1b\xbf\x81\xc4l\x94ANp\x0f0`\xbe\x90l\xf6}\xdf\x01MIf\xe9\xed\xfb\xadk\xc0\x98_\x06\xf3\x0e\xee\x8ex\x98\xd4\xc5\xb8\xaa\xe1\xcf\xbb\x18\x12\xdf\xd7\xb4=_l\x86\x06\x10k', b"\xbdk\xaa\xafWo\xbdO\x00WA\xcf\x86\xa0{#o]$]\x11\x85\xc7\xf0\xce\xf7\x9b\xe4F\x1b\x17*\x10\t\x9at\x1a\x97\xf9\xcb\xabT2\x0c\xa5\xd4\xe8\xd7?$\xbaG'&\xf2\xe5", b'bx\xb93\n\xa7\xa0\x80Z\x81t]:\xcf\x1c\xa4\xbc\xbf\xf9uq\xb9\xe7\xb1\xd8\x1c\x14a\x1d\x9bH\xa6J,\x91\x9cZ\x1a\x08J{\x9c0\x1e\x99\x9d<\x89\xe3,\x94=\x85k\xf2L', b'\xea\xd0\x08z\xa2K\xa5\xcc\xe0\xb0mJ\x90\x1e\xe0\xf5\x1fy\xb9\x1f\x1f\\\x01Nw\x83\xd7\xd0F\x8f8\xaf\xe4a\x91\x9fp\xdc\xb7\xcc;\xf0\x06\xa7M\xadm*N%D6\x16\x1f\xc7\xb3', b"\t[\xb2Z\xea\x97\xee\xbb'\xb1\xb76\xb4\xa2f\xeaQ\xaf\x1e\x98Yt\x19d\xd2\x9f\xd6F\xe6\xf0\xddh\x02\xf3:\xaa\x89+\xd0J\x03y\x1b\x18n[\x1c\xafP\x85!2\xe3\x9d\x80\xf4", b'V\xc8B\x13\rD\x10V\xb9\xc0\x93S\x15\xaa$.\x04\x82\x94\x8cZ8\xa5\x8b\xe1_\xe7\xd89\xde\xfb5R#\x13qWiN\r\x17\xa4<\xd2N\x82\xa7O\xb6A\xab\xb0\xc4g\x9e\x88', b'@\xb5\xad\x91\xe4\xff\xb9\xe2$\xab\x8dy\x9c\xbd\x80\xb1\xe6\x8d(\xba\xef\xba\x93u\xb0-\xb8\xf3\xf7:\x1e\x89\xd1\xf38\x96/\xf2z\xb5\x86&\xcf\x9a\xd2\x1e\x10\xf0\xda\x12[\xff\xb8\x9b\xec\x1b', b'\x03\xa3\xef\xff\xb4%H\x8e\x9fr\x10\xc0rA\x14\xe4\xda)\x0f\x18\xa6j][3\x0c\xb8\x9b\xe4L\xfa\xe0iF\x161\x1b\x903G2\xfb\xdd\xe8z6\xe4Z9\x03\x06\x8e\x9d\x8bx\xae', b'\xb3d\x88=\xd0\xad\x97@\xa6\xdeXa\xfd\x19f\xa6o\xd7\xf7%\xa59}Dr\xd1)S\x101u\x0bMk\xad\xa0\xf8\xe5#\xa2UZ\x138\xd1$\xd5=4\x8bb\xdf1\xfb\xa2\xcd', b'1\xaa\x84\x17\xbe\xc1\x84\x05\x11\x05\xdd\xd7:\x9e\xe0nv\x02\xd7U\xe9\xad\xcf\xdfAU\x8d\xd3I\xf2;\xb3\x850\xcd\xea\x85,\x98Zi ez\x9e\x14en\x1c\xdb-o0\xe0\xb5"', b"\x06\x95\xe9Xl2\x94\x9f)C\x05~\xb4/\x80\xf1\xf6\x18\xa3\x99a\xb8'(\x17\xa8\xd8\xafZp*\x7f\x0e\xe3\x1f(\xb9\xac\xff\x95\\0AX\xdd\xdc\x98g\xbf\x19\xb2\xcf\xe7[{\xc1", b'\xae3z\xb7\xf7:\x00\xa5\xf3\xe0\xf4\xe4\xdb/\xe0i?\x90\xc3Djq\x12i\xbfLC5\x9d\xf3F\x99\xae\x1dC\x9d4\xf6\x8d\xda\xe2\xca\xd6\xf6-\xca\xb5\x12\x9c\x0e\xe6\xac\xbb\x9a.\xf6', b'\xc9\x16\xb3J\xa5i\x83+IH\xf5z.qN\xdc\xd3!\xd0\x85%?\xdaK\xd0\x01\x04x~xh>\xadCLHm\xc1"oCy"mnJ~\xcc d\xd5\xa2\x06P\xfd\xe4', b')\x87\xbc3\xc1*9C\xee\x17\xd4u\x087\xc9\xcc,\x0b\xbdJ\xe9\x89"\\\x1f_gc&\xe2\xf5O\x03\x06\x05\t\xafB\x14\x18P:sd\xfbV\xf9\xde3#\x82M\x95\xeb\x0c\xb8', b'G}+\xfa763+\xaa\xa9\xe8t\x86\xe1\xac\xcc\x0b\x9fjD}/\xf2\xae\n\xbc\x14\x99\x90\x93\x83\xa1\xad\xbe\xd3=Z\xe2A\xffA\xc1z\xd4\xb7\xc4$\xa9\xf80\xb3\x9ag~Lu', b'\x1b\x89%\x932\xe9\x16]\x08\xe7\x8c1U?\xbdG\x11\xb4\xb3\xb6wa\x97\x93\x89\x91\xfbf\xca\xc7\xc4\x80KRX\xe08\xad\x93\rm\xfa\xc8\xcc9\xb8\x93\xbcA\r\xd0\xed\xc5\x9c\x95A', b's@\xfc9m\x8e\xa8\xe6i\xbb\r\xa0\x1aJ\xf7%\x97\x85\x7f]\xb7\xdce\xf63\xb9--\xfe\xd4\xbc\xa3\xfdO\x00xO8]m\xf0TM\xb1\x89\xff\xa4R\xef\x82\x17\x9fw:\x15\xc0', b"\xa3/\xcdn\x13'?!\x03D\xfeu)\xa5\xdd\x89P=\xca\xa1[\x1f\x80\xb9\xed\xc4\xe6\xc6\xd42#d\x04\xe3`/\x1d\xbee+\xde\x1bg\xe3\x9a\xadX\x0e\x8c\xcf\xf6hE\xf0\x08\xa6", b'I\x1d\xf2\x06\x87\xbb\xcb\x0c\x8b\xc5\x1b\xc6\x84d\xb1\xf6\x88\x89&Q\x1a\xc4\xbc\x8a\x85\x8f\xc1\xe5\x1f\xc8q\xbc\xc8\xe7,F\xe1\xdfm\x8e\x18\xe9\xca \xce\x06\x15\xfbs\x02\x039\xe4\xb9h\x83', b"\xb2\xa6\xca\x01\x9bE\xe3\xa4i\x08\xd8\x9a\x16b\xb8\x94\xf6P6\xab\x05\x89\xf8\xb0\xa2q'\n\xb3\x8diT\x0b\x80~\xc0\xd2%\x0f\x92GFA\x88\xdea\x1d\x11\xed>\xc8#\x0c#?t", b'\xbb\xe0\x86\x9e\xe5\x16\xb8\x9cy\x08\xd3)\xbc|@D\xeeh`\x16G\x15W\x91\xcc\xd7\xdbmD9\xe1\xe5\xe8t#3\xf9\x1cEvk;\xd3\xe7\x8e\xb4\xbc\x85\xb0\x1f\xdf\xea\xb6\x0cSf', b'\xc9\x8d\x8eY~U\x94\xeb\xb5\x12\x08\xcci\x0fU\x1b\x9d?Q)9\xd5\rel\xd6R\x18\xa7|O+?\xf3\t\x0f\xcb\x0f*;e\xffe\xd6c@\xe8K\xa2\xa4\xbem\x08&P{', b"\x15T\xf3\xdb\xa0QJ\xf9\xb3\x11\xdd\x9e\xef\xe5\xb4c\x1a\x9b\xd2g\xe3\xff'\x90V\x89\xea\x8d\xe2\xd0\xb6\xa3\xe6\rO\x8b\xc6\x9c\xe6\x87w\xac{\x1e<\xce\xbc4\xd0\xa6\x15?A\x0ek\xc9", b'\x91i\xa9\x83L\xd6\xe8\xc8\x1fK\xfc\xceM\x88*\xc5\x15\xad\xd8y9-}Z\x96\xbaA\xba\xc1\x94r\xb8e\xd7\xbd\xaa\xab\xc8nS\\\x8c1\xc8\xa3\xb3f\xfa\xe9\xa3\x12\xb0\xb1w\n\x9e', b"\xdf\x07\xb0\xa7w\xe2`\xed\x1eY\x1f\xecA2_\x82\xc8\xbb\xb0p<\xca\x11imiPV\x98\x9b'\xaf\x8a\xac&oj\xaeN\x8a$\xcd=u\xce\xc1\xec\xec\xbb^}\xb52v\x06\x00", b'\xbe\xcc\x83\xaa\xbe2\r#$d\xa3;\xdd\x97.\xc8\xb3\x85{N\xfbF\x853\xd1f\r\x19\xdd\x9fp>\x08\xcf\x8d\x7f\xa1\xf6\x7f";W^\x82\x88<\x99\x88\xd8\xe8\x91\x89#s\t\xa2', b'\xe3\x8e\xe8]S\x8da#o\x9a\xae`\\z\x9ay\xbcF?\xf2\x9b\x07\x97Z\xf3\xe9\xea\xcd\xb6AW\xbe5!\x00\xed\x8c\xbc\x8d\x80\x91\x86\x89\rA\x1c\x80ua\xa9.\xdd\xd5\xe8\x86\\', b'\xcb\xd7%/\xd1\x8e\x0e\xd0\x8a<\xf9rg\x00\xef\x11\x05\xfc6\xb1\x85^\xdf\x92\x9f!Z\xe6#\xec\xbd\xb8\x80\x12\xe1B9[4\xcc\x90-\xaa\x1f\xdd+S\x1f\tk\xf8\xc8\xc9=}\x8b', b'\xb1\xa1\xbd\xfa"\x8a\xd9\xc2H\xff\r\xeb\xff\xae\x0b\x90\xa6:\x85\x0f\xa9f\x0e\xc5C\xa5\'e\xd8:\xa2qF\x91\xfb\x92\x95M\xf4I\x8dw\x8ft^\xb7c=\x9ck\x8e\xb2 \x8f6 ', b'@?m<z\x99a\xba\xb4x\xda\x82\xe8\x9a\xe2`l\xb5\xa4\xd7;\x92\xab\x80\xac\xe1\xe4\t\x94\x02\xfdd\xb0%\xd6\xc0\xcb\xb8;\x00\xc08\xcd;\xb4\x87&\xcb\x07\x19\xc4\xce\x08)\xe8\x10', b'\xb1\xb7\xb0\x86.\x99o\xb3\xef%\xfe!U\xb3\x17$\xb1/\xb2)\xcc\xe8yA\x80\xc6z\xdb?\x1e\xa6\xcf6#*\xdb>e\x08\xbf\x1d\xa9\x15\xb5\x0bUF\xb3(\xcf\xffR@\xbej\x80', b'e\x1c|T\x86a,\x92\xd9\xcf\xc7\xe7\xda\xf2\xd5\xa1L\xaf\x06\x901\r\xfa4\xc4\xa6\x93\x8c>\x01\x82/K\x9f\xd3\xfa\xa7\x1cy\x99p\xa7;3\xbap\xa6\xa6\xdc\r\xc1%P\xc5\x9f\x84', b'\xeaz\x0f\xcf\x99\xee\x1c[\xed\x0fY8\x92\xe0:\x13\t\n\xf1\xbfZ\xc6\xeea\xad\xa3\\\xb2\xf6\xd0p\xc8\r:H\x84\xf4\x0b\x05\xdc\xa27\xfb\xa2n.\x9fK\xb0\xed*\x04\xd3\xf0\x0c\xbf', b'\x80\xf9a\xcb:\x98\xe9\x96Dw\xc7n\xee\x8bl\xed-\x11&7\x11\xf5\x12&\x9aM}\\\xe4t8\x9d\x15\xd8\xd3\xf0js\xd1[\x1b\x893p\x058\r\xe5[\x8bxc\xc1\xa4\xa0S', b"\xa8a\x9b\x8a\xeb\xd2k\x17\x19\x92TFg\x8e\x10\xe04\x0bqCC\x8f\xad/s\x87;\x9c\r'\x17h1\xed@4N~\xc0PIL\xa7\x83\xba\xc2'WeuW\ns\xdfr\xe3", b't{\xaa\xf6\xdd\xc1>\xb8\x96I\xda\xe5\xaf/Z\x92\x02\xa2\x88\xc8c\x8c\xd9\xa0G\xc59.\\\xef>IA\x91\xe5(\xda\xbd~\xc5\x00.ip\xe8\x85k\x04\x84\xeaP\xd9\x07\xeb\xd4q', b'o\xa8\xd7k\xf9\xd8\xe2A!\x8c\x1c\x03\x0c\x86\xb8\x96\xaf\xff\x01%W\xa0s\xfc\nN+Y%\x9dj"l\xb1\x01\xb1\'\x0fPY\xc5\xb2\x86@\x99~\xaf\xf9\x8c|MDY\xe6k!', b"+=K\x12\xd9l\xdf\xa2\xf8Uw\x84\xd2\xfb\xb8LWd\x12'Z\x97\x0b\x08\x9a\x9d\x9f\xd9/gtL\xba\xc9\xaeC,\xfd+_\xe6q\x99\xe7\xaf]\x9a\xb7\xff\xfbO@M\xd1fK", b'\x81\xe8\xc3\x13\x84\xeb+\xf5\x12\x16\xcam\x07n\xc7\xe7\xf8;z\xc5\xeb\xd4\\\xd9\x8d\x93\xc77\xac\xe5\xe7\xd4\xd3ZY\xcf\xdb#\xeb\xb9\xef\xf8\x16\x95\xad\xdc\x07\xe8\xd1\x0b\xcc\x15\xeeO\xf6<', b'\x066\x87\xc1\x86\x1a\x12\x02\xfe\x86\x91\x98kE"\xa4\x1di\x9c\x8e\xac\xa0\x98kn\x80`4\xfd\x9d\x83\xc3\x9c\xb9v%\x81\'I\xc10\xe0dy\xadm\x8e\xb9\xf5AL\x140:w2', b'x\xe6\xc2\xfcu\x91\xff\xab\x94\xe7ecQO@\xe9C\xe0b\xbc\x1e\xd3x\xda\x98\x9e\xf0U+\x1e\n\xf7\xa4\xbc|\x87D~\xdd\xfee\xe2o\xb0Mu\xf7\xf3I\xdb\xe7\x1d\x89p\x91\xbf', b'8"\x94\x86Hr[\xad5\xea\x84:S\xac\xf8\xffr\x01\\m\x8e+\x989zu\xf0\x9b\xf3L8"58NF\xdb\x93\x84p\x96\xd9\x91x\x06^7\xfei$\xdb\xcf\xe3|\xa9\\']
L = matrix(QQ, mat)
target = [777608, 732754, 589323, 634380, 705876, 732504, 700040, 653799, 701951, 606866, 650760, 707791, 635433, 774691, 725287, 662287, 621134, 688301, 698696, 594769, 816833, 627640, 680818, 669979, 668393, 770865, 617394, 558903, 725342, 694882, 716532, 654891, 712000, 635559, 715192, 580986, 782500, 762735, 668963, 670527, 711679, 680067, 708304, 722481, 647503, 707975, 694053, 658708, 590330, 741846, 615948, 684794, 815580, 626108, 803846, 650642]

target = vector(target)

res = L.solve_right(target)
flag = "".join(map(chr, res))
print(flag)  # flag{the_true_name_of_this_challenge_is_KUSO_PICKLE_2.0}
```

## あとがき

Satokiさんに自己紹介した時に「(私に対して) Pickle職人の方ですよね？」と言われなかったらこんな問題は作らなかったので苦情は私ではなく彼にお願いします。
