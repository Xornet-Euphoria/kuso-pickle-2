先日開催されたSatokiCTFで Sickle 2.0という問題を出題したのでそれのWriteupになります。

## Prerequisite

- Pickleの仕様
- API Hashing

## TL;DR

- Pickle上で擬似的な関数呼び出しとレジスタを実現しついでに難読化をそこそこ施したVM
    - 流れはVM初期化 → 入力の取得と長さのチェック → 入力と対応するベクトルに左から行列を掛けてその結果を照合 → VMのコンテキストを爆破して終了
- デシリアライズの際に`pickle.loads`で別のバイトコードをデシリアライズすることで実質的に関数呼び出しを実現
- `load_extension`を内部で呼び出す`EXT1`, `EXT2`, `EXT4`は (本来の目的を無視すれば)`copyreg._extension_cache`から要素を取得するため、ここを引数渡しのレジスタやグローバルアクセス可能な領域として利用
- 書き込みはこの領域が辞書なので `SETITEM`や `SETITEMS`を使うと実現可能
- 多くの `STACK_GLOBAL` での呼び出しをAPI Hashingにして難読化

## 実装した~~嫌がらせ~~難読化

- バイトコード中で `pickle.loads()`を `REDUCE` で呼び出して各機能を実行することで配布されたバイトコードだけを逆アセンブルしても意味が無いようにした
- 0から255までの値、関数やメソッド名のような登場するとわかっている文字列、後述のAPI Hashingで使用するハッシュ、内部の `pickle.loads`で呼び出すバイトコードを全て `copyreg._extension_cache`に放り込んでバイトコードやその逆アセンブル結果からのGuessを困難にした
- バイト列中に`REDUCE`で呼び出す関数は大抵 `GLOBAL`や `STACK_GLOBAL` で取得するが、この際バイトコード中にモジュールとオブジェクト名が直書きされることでGuessが可能なのでAPI Hashingと同様の方法で習得
- 実行終了後の`copyreg._extension_cache`を確認するとどのインデックスにどの要素があるのかが丸わかりなので、最後に`copyreg.clear_extension_cache`を呼び出して空にした
    - これを呼び出さなければ余裕で回避可能
- 再帰的なバイトコードの呼び出しによるループの実装
    - Pickleには制御構文用のオペコードが無く、 `map`や `filter` を `REDUCE`で呼び出す以外にループを実現することが困難
    - 今回は `pickle.loads` で別のバイトコードを呼び出せるので、そこで再帰呼び出しをすればループができる
    - `def f(loop_cnt): ...` のような関数を呼び出して `loop_cnt` の値を操作 (インクリメントやデクリメント) し、その結果次第で再帰呼び出しするか何もしない (呼び出し元に戻る) かで分岐する

## 難読化詳細

### API Hashing

Pickleで`from module import something`相当の事をする際は`STACK_GLOBAL`や`GLOBAL`オペコードを使用します。しかしこれは前者はスタックトップの2つの文字列を用いることから、付近に文字列をpushする命令があると何をインポートしているかが直ぐわかります (実際バイトコードの先頭で`pickle.loads`をインポートしている)。後者の場合は後続のバイト列をそのまま使用するため、逆アセンブルすればスタックの様子を見ずとも確認可能です。これまでPickleのRevを解いたり作ったりしてきた中で、このオペコードがGuessの要因や解析ツールの支援となることがあったのでなんとかしてそれを防ぎたいと思って生まれたのがPickle中でAPI Hashingを行うという発想です。

API Hashingの仕組みは単純で、関数呼び出しの際にハッシュをリゾルバに渡し、リゾルバはライブラリやその中にある関数を列挙してハッシュ化しながら一致するものを探して該当の関数を返すものとなります。Windowsのマルウェアや位置独立なシェルコードが関数ポインタを取得する際に見られるテクニックらしいです。

Pythonでは`sys.modules`に標準ライブラリから読み込めるモジュールが名前をキーとした辞書で入っているため、ここを列挙&ハッシュ化していけばモジュール名の解決は可能です。モジュールが手に入ったらこれに対して`dir`関数を実行することで要素名を列挙出来ます。この中には当然モジュール内の関数も含まれているため、そのハッシュ値を指定することで無事に関数が取得出来ます。

問題作成用のスクリプトを確認したら次のような事をしていました。

```python
list(
    map(
        _hashlib.HASH.hexdigest, 
        map(
            hashlib.sha256,  # -> sha3_512 
            map(
                builtins.str.encode,
                sys.modules.keys()
                # or: dir(sys.modules["copyreg"])
            )
        )
    )
)
```

なお、最初はSHA256でハッシュ化していましたが、Crackstationでハッシュ値を解析したらcopyregは出てきてしまったのでSHA3_512に変更しました。

### バイトコード中で`pickle.loads`

pickleのバイトコードでは`REDUCE`オペコードを使うことで、任意のPythonの関数を呼ぶことが出来るというのは言わずとしれた事実です。したがって、`pickle.loads`も当然呼ぶことができることからバイトコード中で別のバイトコードを実行出来ます。

これで普通にプログラミング言語における関数呼び出しに相当することが可能になります。この問題では難読化に用いるあらゆる値 (API Hashingのハッシュ値、`getattr`や`int.__add__`のような汎用的なビルトインの関数、このような形で呼び出されるバイト列) を後述のグローバル領域 (`copyreg._extension_cache`) に配置する処理をはじめとしていくつかの処理をバイト列に分解して呼び出しています。

但し、特に工夫を施さない場合は引数を渡すことが出来ないのでこれを実現する手段が必要です。

### `copyreg._extension_cache`や`EXT<n>`オペコード

### 再帰を用いたループ

## 解法

レビューしていないのでどのレベル帯の人が解けるかは想像がつきませんが、手っ取り早いのはpickle.pyやpickletools.py辺りをコピペして改造していい感じの解析スクリプトを書くことだと思います。この問題に直接適用するのは難しいかもしれませんが、Pickleバイトコードのデバッガを実装した例があります: [Legoclones/pickledbg: A GDB+GEF-style debugger for unloading Python pickles](https://github.com/Legoclones/pickledbg/tree/main)。

特に、この問題では`pickle.loads`を使ったバイトコードの呼び出しや、使っているところを見たことがない`copyreg._extension_cache`、`EXT`系の命令等、pickle.pyを読んで理解する必要がある概念がそこそこあるのでこの辺のサポートを追加する必要があります。

これをやった上で、API Hashingを利用した`STACK_GLOBAL`の難読化や再帰関数を利用したループには特定の命令列パターンが現れるはずなのでそれを元にして気合で元のPickleのコードやPythonのコードに直していくという気合が必要です。

難読化の正体が分かってしまえば、後はPickleの逆アセンブル結果を気合で読むだけなのでRevに慣れている人なら解けるだろう、という読みでした。Pickleには制御構文がないので、Pythonで標準搭載している高階関数(`map`, `filter`等)や真偽値をインデックスにとって次に呼び出される関数や引数を選ぶといった形で実装された一部のループや条件分岐にも対処する必要があります。

他に必要なテクニックとして、そもそもPickleがスタックマシンなのでメモや`copyreg._extension_cache`に入れる過程であっても必ずスタック上にその要素が現れ、それを適宜確認するというのがあります。今回の行列演算で使う行列や演算結果の比較対象もどこかのタイミングでスタックに乗るので、そこまでのバイト列を切り出して`pickle.STOP`を末尾に付与してloadするとそれがデシリアライズ結果として返ってきます。

この問題での例を挙げると、フラグチェックで登場する行列が本体をスタックに乗せた後に`getattr(matrix, "__getitem__")`を用いてgetter相当の関数に変換されており、演算時にはスタックに存在していません。そこで、getterを取得する寸前で止めてデシリアライズすることでバイト列の配列にエンコードされた行列を取得することが出来ます。

## やらなかったこと

- 難読化を解除したとしてもCrackMeパートで公開鍵暗号の知識やSMTソルバを持ち出さないと解けないようにする
    - 今回はただの行列演算
        - `sum(map(int.__mul__, row, col))` を各行でやっている
    - Cryptoではないのでやめた
    - 加えて、どうしてもこのパートはループが発生することから、クソ重たい処理を今回のような再帰で書きたくなかった
- `copyreg._extension_cache`に、何らかのバイトコードへのI/Oを置いておき、そのバイトコード中でそれを操作 (特にseek) することでループを実現
    - 今回のアイデア + SECCON CTF 2023 Quals - Sickleの合わせ技
    - これで擬似的なIP (インストラクションポインタの方) となるので、eval, exec, Pythonバイトコードの利用、ファイルポインタ変数が既知という仮定などを使わずに、Pickleの機能だけで制御構文とレジスタを持つ高機能なスタックベースのVMをシミュレートできる予感
- 動的なバイトコード生成
    - 文字列やバイト列をスタックにpushする際、大抵「オペコード」、「長さ」、「文字列やバイト列に対応するバイト列」のような並びになるので、長さやバイト列の部分をスタックに乗せて `bytes.__add__` や `bytes.join` 等で結合すればバイトコードをPickle中で構成できる
    - 当初は別のバイトコードへの引数渡しをこれでやるという案を検討していたが、 `copyreg._extension_cache` の発見と研究により終了
- その他、今回の問題の本質に関連しない難読化
    - メモにぶち込む命令 (`PUT`系)はスタックや大抵のコンテキストに影響しないため、使わないインデックスに対して連発すれば実質的なNOPとなる
    - 加えて、バイトコード中で同一インデックスに対する `PUT` を行うとpickletools.pyがエラーを吐いて解析が困難になる
        - pickletools.pyへの対策案はそこそこ抱えているが、ほとんど実装しなかった
    - ここに書くレベルですら無い実質NOPのような命令列の使用 (意味のないスタック操作命令等)

## あとがき

Satokiさんに自己紹介した時に「(私に対して) Pickle職人の方ですよね？」と言われなかったらこんな問題は作らなかった。
