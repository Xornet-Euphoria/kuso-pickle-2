先日開催されたSatokiCTFで Sickle 2.0という問題を出題したのでそれのWriteupになります。

## Prerequisite

- Pickleの仕様
- API Hashing

## TL;DR

- Pickle上で擬似的な関数呼び出しとレジスタを実現しついでに難読化をそこそこ施したVM
    - 流れはVM初期化 → 入力の取得と長さのチェック → 入力と対応するベクトルに左から行列を掛けてその結果を照合 → VMのコンテキストを爆破して終了
- デシリアライズの際に `pickle.loads` で別のバイトコードをデシリアライズすることで実質的に関数呼び出しを実現
- `load_extension`を内部で呼び出す `EXT1`, `EXT2`, `EXT4` は (本来の目的を無視すれば) `copyreg._extension_cache` から要素を取得するため、ここを引数渡しのレジスタやグローバルアクセス可能な領域として利用
- 書き込みはこの領域が辞書なので `SETITEM`や `SETITEMS`を使うと実現可能
- 多くの `STACK_GLOBAL` での呼び出しをAPI Hashingにして難読化

## 実装した~~嫌がらせ~~難読化

- バイトコード中で `pickle.loads()`を `REDUCE` で呼び出して各機能を実行することで配布されたバイトコードだけを逆アセンブルしても意味が無いようにした
- 0から255までの値、関数やメソッド名のような登場するとわかっている文字列、後述のAPI Hashingで使用するハッシュ、内部の `pickle.loads`で呼び出すバイトコードを全て `copyreg._extension_cache`に放り込んでバイトコードやその逆アセンブル結果からのGuessを困難にした
- バイト列中に `REDUCE` で呼び出す関数は大抵 `GLOBAL`や `STACK_GLOBAL` で取得するが、この際バイトコード中にモジュールとオブジェクト名が直書きされることでGuessが可能なのでAPI Hashingと同様の方法で習得
- 実行終了後の `copyreg._extension_cache` を確認するとどのインデックスにどの要素があるのかが丸わかりなので、最後に `copyreg.clear_extension_cache`を呼び出して空にした
    - これを呼び出さなければ余裕で回避可能
- 再帰的なバイトコードの呼び出しによるループの実装
    - Pickleには制御構文用のオペコードが無く、 `map`や `filter` を `REDUCE`で呼び出す以外にループを実現することが困難
    - 今回は `pickle.loads` で別のバイトコードを呼び出せるので、そこで再帰呼び出しをすればループができる
    - `def f(loop_cnt): ...` のような関数を呼び出して `loop_cnt` の値を操作 (インクリメントやデクリメント) し、その結果次第で再帰呼び出しするか何もしない (呼び出し元に戻る) かで分岐する

## 解法

レビューしていないのでどのレベル帯の人が解けるかは想像がつきませんが、手っ取り早いのはpickle.pyやpickletools.py辺りをコピペして改造していい感じの解析スクリプトを書くことだと思います。この問題に直接適用するのは難しいかもしれませんが、Pickleバイトコードのデバッガを実装した例があります: [Legoclones/pickledbg: A GDB+GEF-style debugger for unloading Python pickles](https://github.com/Legoclones/pickledbg/tree/main)。

特に、この問題では `pickle.loads`を使ったバイトコードの呼び出しや、使っているところを見たことがない `copyreg._extension_cache` 、 `EXT` 系の命令等、pickle.pyを読んで理解する必要がある概念がそこそこあるのでこの辺のサポートを追加する必要があります。

これをやった上で、API Hashingを利用した `STACK_GLOBAL` の難読化や再帰関数を利用したループには特定の命令列パターンが現れるはずなのでそれを元にして気合で元のPickleのコードやPythonのコードに直していくという気合が必要です。難読化の正体が分かってしまえば、後はPickleの逆アセンブル結果を気合で読むだけなのでRevに慣れている人なら解けるだろう、という読みでした。

## やらなかったこと

- 難読化を解除したとしてもCrackMeパートで公開鍵暗号の知識やSMTソルバを持ち出さないと解けないようにする
    - 今回はただの行列演算
        - `sum(map(int.__mul__, row, col))` を各行でやっている
    - Cryptoではないのでやめた
    - 加えて、どうしてもこのパートはループが発生することから、クソ重たい処理を今回のような再帰で書きたくなかった
- `copyreg._extension_cache`に、何らかのバイトコードへのI/Oを置いておき、そのバイトコード中でそれを操作 (特にseek) することでループを実現
    - 今回のアイデア + SECCON CTF 2023 Quals - Sickleの合わせ技
    - これで擬似的なIP (インストラクションポインタの方) となるので、eval, exec, Pythonバイトコードの利用、ファイルポインタ変数が既知という仮定などを使わずに、Pickleの機能だけで制御構文とレジスタを持つ高機能なスタックベースのVMをシミュレートできる予感
- 動的なバイトコード生成
    - 文字列やバイト列をスタックにpushする際、大抵「オペコード」、「長さ」、「文字列やバイト列に対応するバイト列」のような並びになるので、長さやバイト列の部分をスタックに乗せて `bytes.__add__` や `bytes.join` 等で結合すればバイトコードをPickle中で構成できる
    - 当初は別のバイトコードへの引数渡しをこれでやるという案を検討していたが、 `copyreg._extension_cache` の発見と研究により終了
- その他、今回の問題の本質に関連しない難読化
    - メモにぶち込む命令 (`PUT`系)はスタックや大抵のコンテキストに影響しないため、使わないインデックスに対して連発すれば実質的なNOPとなる
    - 加えて、バイトコード中で同一インデックスに対する `PUT` を行うとpickletools.pyがエラーを吐いて解析が困難になる
        - pickletools.pyへの対策案はそこそこ抱えているが、ほとんど実装しなかった
    - ここに書くレベルですら無い実質NOPのような命令列の使用 (意味のないスタック操作命令等)

## あとがき

Satokiさんに自己紹介した時に「(私に対して) Pickle職人の方ですよね？」と言われなかったらこんな問題は作らなかった。

個人的に、esolangとして遊んでいた割には妙に高機能 (Pythonの関数を呼び出せるから当然) で変なことができて新たなVMとしての利用やループの可能性が広がり、計算理論の事を思い出させられたのが面白かったです。